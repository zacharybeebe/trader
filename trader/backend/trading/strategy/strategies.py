"""
A collection of different trading strategies
"""
import talib
from .strategy import *


#####################################################################################################################################################
# Combo Strategy ####################################################################################################################################
class Combo(Strategy):
    """
    This class is where you can combine individual strategies together. Submit the classes in either the "and" list or the "or" list\n
    The Combo class buy and sell signals will be generated by the buy and sell signals prepared buy the individual strategies.\n
    The "and" list will only generate buy/sell signals when ALL strategies in the list are generating signals at a certain period.\n
    The "or" list will generate buy/sell signals when ANY of the strategies in the list are generating signals at a certain period.\n\n

    There is a flag "and_strict" for if you have both "and" and "or" lists, which if True then both lists must be generating a buy/sell signal.\n
    If False then only one of the lists must be generating a buy/sell signal\n
    The individual list rules still apply in this case, for example:\n    
    \t"and_strict" is True: All of the "and" list must be generating signals, AND any of the "or" list must be generating signals\n
    \t"and_strict" is False: All of the "and" list must be generating signals, OR any of the "or" list must be generating signals\n\n

    The lists can contain the classes or dictionaries with the class as the key and the class init parameters as the sub-dictionary\n
    Do not include instantiated strategies as this will throw off the shared data DataFrame\n\n

    Examples:\n
    ```python
    # Using just the strategy classes
    df = pd.DataFrame(...)
    combo = Combo(and_list=[TRIMA, Bollinger], or_list=[FibonacciRSI], data=df)

    # Using the strategy classes with parameters
    df = pd.DataFrame(...)
    combo = Combo(
        and_list=[
            {'TRIMA': {'period': 10}},
            {'Bollinger': {'period': 20, 'stddev': 2}}
        ], 
        or_list=[
            {'FibonacciRSI': {'period': 14}}
        ], 
        data=df
    )
    ```
    """
    # Constructor #################################################################################################################################
    def __init__(
        self, 
        and_list: Optional[list] = None, 
        or_list: Optional[list] = None, 
        and_strict: bool = True, 
        data: pd.DataFrame = None, 
        use_data_inplace: bool = False, 
        column_mappers: Optional[dict] = None
    ):
        if and_list is None and or_list is None:
            raise ValueError('Must provide either an "and" list or an "or" list or both lists')
        if and_list is not None and or_list is not None:
            self.and_list = and_list
            self.or_list = or_list
            self.has_both_lists = True
        else:
            if and_list is not None:
                self.and_list = and_list
                self.or_list = []
            else:
                self.and_list = []
                self.or_list = or_list
            self.has_both_lists = False
        self.and_strict = and_strict

        # Initialize the Strategy
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=True,
            init_prepare=False
        )

        # Create the Strategy Instances
        self.and_strategies = []
        self.or_strategies = []
        for init_list, append_list in [[self.and_list, self.and_strategies], [self.or_list, self.or_strategies]]:
            for item in init_list:
                if isinstance(item, dict):
                    for strategy_cls, params in item.items():
                        append_list.append(self._init_strategy(strategy_cls, params))
                else:
                    append_list.append(self._init_strategy(item))
        self.ands_off = []
        self.ors_off = []
        self.prepare()

        for strategy in self.and_strategies + self.or_strategies:
            self.indicators += strategy.indicators
        
        # Update the parameters dict with parameters from the individual strategies
        for strategy in self.and_strategies + self.or_strategies:
            self.parameters[strategy.__class__.__name__] = strategy.parameters
    
    # Abstract Prepare Method (must override Strategy prepare) ######################################################################################
    def prepare(self):
        # Prepare the buy and sell columns
        self.data['and_buys'] = 0
        self.data['and_sells'] = 0
        self.data['or_buys'] = 0
        self.data['or_sells'] = 0

        # Reset the buy and sell columns in the case that signals are being reprepared
        self.data[self.buy_column] = np.nan
        self.data[self.sell_column] = np.nan

        # Prepare the "and" strategies
        for strategy in self.and_strategies:
            if strategy.__class__.__name__ in self.ands_off:
                continue
            self.data.loc[self.data[strategy.buy_column].notna(), 'and_buys'] += 1
            self.data.loc[self.data[strategy.sell_column].notna(), 'and_sells'] += 1

        # Prepare the "or" strategies
        for strategy in self.or_strategies:
            if strategy.__class__.__name__ in self.ors_off:
                continue
            self.data.loc[self.data[strategy.buy_column].notna(), 'or_buys'] += 1
            self.data.loc[self.data[strategy.sell_column].notna(), 'or_sells'] += 1

        # Set the buy and sell signals
        len_ands = len(self.and_strategies) - len(self.ands_off)
        
        if self.has_both_lists:
            if self.and_strict:
                # If "and_strict" and both lists are present, then both lists must be generating signals
                # All of the "and" list must be generating signals, AND any of the "or" list must be generating signals
                self.data.loc[
                    (
                        (self.data['and_buys'] == len_ands)
                        & (self.data['or_buys'] >= 1)
                    ), 
                    self.buy_column
                ] = 1

                self.data.loc[
                    (
                        (self.data['and_sells'] == len_ands)
                        & (self.data['or_sells'] >= 1)
                    ), 
                    self.sell_column
                ] = 1
            
            else:
                # If not "and_strict" and both lists are present, then either list must generating signals
                # All of the "and" list must be generating signals, OR any of the "or" list must be generating signals
                self.data.loc[
                    (
                        (self.data['and_buys'] == len_ands)
                        | (self.data['or_buys'] >= 1)
                    ), 
                    self.buy_column
                ] = 1

                self.data.loc[
                    (
                        (self.data['and_sells'] == len_ands)
                        | (self.data['or_sells'] >= 1)
                    ), 
                    self.sell_column
                ] = 1

        else:
            # Otherwise, follow the rules for the existing list
            if self.and_list:
                self.data.loc[self.data['and_buys'] == len_ands, self.buy_column] = 1
                self.data.loc[self.data['and_sells'] == len_ands, self.sell_column] = 1
            else:
                self.data.loc[self.data['or_buys'] >= 1, self.buy_column] = 1
                self.data.loc[self.data['or_sells'] >= 1, self.sell_column] = 1    

    # Private Methods #############################################################################################################################
    def _current_parameters_flat(self) -> dict:
        current_params_flat = {}
        for strat_name in self.parameters:
            for param_name in self.parameters[strat_name]:
                current_params_flat[f'{strat_name}_{param_name}'.lower()] = self.parameters[strat_name][param_name]
        return current_params_flat

    @staticmethod
    def _get_parameter_combinations(strategy_params: dict) -> list:
        ###################################################################
        def expand_params(params):
            keys, values = zip(*params.items())
            all_combinations = [dict(zip(keys, combination)) for combination in itertools.product(*values)]
            return all_combinations
        ###################################################################
        formatted_strategy_params = {}
        for key in strategy_params:
                if isinstance(key, str):
                    formatted_strategy_params[key.lower()] = strategy_params[key]
                elif isinstance(key, Strategy):
                    formatted_strategy_params[key.__class__.__name__.lower()] = strategy_params[key]
                elif issubclass(key, Strategy):
                    formatted_strategy_params[key.__name__.lower()] = strategy_params[key]
                else:
                    raise ValueError(f'Invalid Strategy for parameter ranges: {key}')  

        all_combinations = []
        strategy_names = list(formatted_strategy_params.keys())
        param_combinations = [expand_params(formatted_strategy_params[strategy]) for strategy in strategy_names]
        for combination in itertools.product(*param_combinations):
            combined_dict = {strategy_names[i]: combination[i] for i in range(len(strategy_names))}
            all_combinations.append(combined_dict)
        return all_combinations
    
    @staticmethod
    def _get_strategy_combinations(strategy_list: list) -> list:
        # Get all possible combinations of the strategies
        combos = []
        for i in range(1, len(strategy_list) + 1):
            combos += list(itertools.combinations(strategy_list, i))
        # Attach placeholder for parameters
        return combos
    
    def _init_strategy(self, strategy_cls: type[Strategy], params: Optional[dict] = None) -> Strategy:
        strategy_instance = None
        if issubclass(strategy_cls, Strategy) and strategy_cls.__name__ not in ['Combo', 'Strategy']:
            if params is not None:
                strategy_instance = strategy_cls(
                    data=self.data, 
                    use_data_inplace=True,
                    clean_columns=False,  # Keep columns generated from the individual strategies
                    init_prepare=True,
                    **filter_callable_kwargs(
                        func=strategy_cls.__init__,
                        passed_kwargs=params,
                        remove_predefined_kwargs=[
                            'data', 
                            'use_data_inplace', 
                            'column_mappers', 
                            'clean_columns', 
                            'init_prepare'
                        ]
                    )
                )
            else:
                strategy_instance = strategy_cls(
                    data=self.data, 
                    use_data_inplace=True,
                    clean_columns=False,  # Keep columns generated from the individual strategies
                    init_prepare=True,
                )
        else:
            raise ValueError(f'Invalid Strategy Class: {strategy_cls}')
        self._rename_strategy_indicators_after_prepare(strategy_instance)
        return strategy_instance

    def _rename_strategy_indicators_after_prepare(self, strategy: Strategy) -> None:
        # Change the name of the indicators to prefix with the lower strategy class name
        rename_cols = {}
        for indicator in strategy.indicators:
            new_name = f'{strategy.__class__.__name__.lower()}_{indicator["name"]}'
            if indicator['name'] in self.data.columns:
                if new_name not in self.data.columns:
                    rename_cols[indicator['name']] = new_name
                else:
                    self.data[new_name] = self.data[indicator['name']]
                    self.data.drop(columns=indicator['name'], inplace=True)
                indicator['original_name'] = indicator['name']
                indicator['name'] = new_name
        if rename_cols:
            self.data.rename(columns=rename_cols, inplace=True)

    
    def _toggle_strategy(self, strategy, turn_off: bool = True) -> bool:  # bool indicates if changes were made
        # Get the name of the strategy - ignore is not valid
        if isinstance(strategy, str):
            s_name = strategy
        elif issubclass(strategy, Strategy):
            s_name = strategy.__name__
        else:
            self.log_warn(f'Invalid Strategy: {strategy}, ignoring...')
            return False
        
        # Check if the strategy is already active or inactive
        if turn_off:
            if s_name in self.inactive:
                self.log_warn(f'Strategy "{s_name}" is already inactive, ignoring...')            
                return False
        else:
            if s_name in self.active:
                self.log_warn(f'Strategy "{s_name}" is already active, ignoring...')            
                return False

        # Check if this strategy is in the "and" or the "or" list.
        # If it is not in either list then ignore it
        if s_name in self.and_names:
            if turn_off:
                self.ands_off.append(s_name)
            else:
                self.ands_off.remove(s_name)

        elif s_name in self.or_names:
            if turn_off:
                self.ors_off.append(s_name)
            else:
                self.ors_off.remove(s_name)
        else:
            self.log_warn(f'Strategy "{s_name}" is not in this Combo, ignoring...')
            return False
        return True
    
    # Public Methods ##############################################################################################################################
    def backtest_optimize(
        self,        
        cash: float,
        commission: float = 0,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
        close_end_position: bool = True,
        top_n: int = 5,
        parameter_ranges: Optional[dict] = None
        ) -> Union[list[tuple[BackTest, tuple]], tuple[BackTest, tuple]]:
        """
        This method will find the most successful backtest by running all combinations of strategies\n
        This method will iteratively toggle strategies on and off to find the best combination\n

        This returns the most successful backtest and the combination of strategies that generated the backtest\n

        You can optionally provide parameter ranges for the strategies to optimize, for example:\n
        ```python
        backtests = combo.backtest_optimize(
            cash=10_000,
            commission=0.46,
            stop_loss=2,
            take_profit=10,
            close_end_position=False,
            top_n=5,
            parameter_ranges={
                'KAMA': {
                    'period': range(12, 16)
                },
                'ATR': {
                    'period': range(10, 15),
                    'multiplier': [1.5, 2.0, 2.5]
                }
            }
        )
        ```

        """
        # Get all combinations of "and" strategies
        and_combinations = self._get_strategy_combinations(self.and_names)
        or_combinations = self._get_strategy_combinations(self.or_names)
        all_strategy_combos = []
        if len(and_combinations) == 0 and len(or_combinations) == 0:
            raise ValueError('No strategies to optimize')
        elif len(and_combinations) > 0 and len(or_combinations) > 0:
            for and_combo in and_combinations:
                for or_combo in or_combinations:
                    all_strategy_combos.append(and_combo + or_combo)                    
        elif len(and_combinations) > 0:
            all_strategy_combos = and_combinations
        else:
            all_strategy_combos = or_combinations
        
        # Format the parameter ranges keys
        all_param_combos = None
        if parameter_ranges is not None:      
            all_param_combos = self._get_parameter_combinations(parameter_ranges)
                
        all_combos_and_params = []
        total_iterations = 0
        for combo in all_strategy_combos:
            all_combos_and_params.append([combo, None])
            combo_lower = [s.lower() for s in combo]
            total_iterations += 1
            if all_param_combos is not None:
                using_parameters = []
                for param_dict in all_param_combos:
                    use_param_dict = {}
                    for strat_name in param_dict:
                        if strat_name in combo_lower:
                            use_param_dict[strat_name] = param_dict[strat_name]
                    if len(use_param_dict) > 0:
                        using_parameters.append(use_param_dict)
                if len(using_parameters) > 0:
                    total_iterations += len(using_parameters)
                    all_combos_and_params[-1][1] = using_parameters
                
        best_fv_combos = []
        at_run = 0
        try:
            with TimerInline('Optimizing Strategies Loop', print_starting=False) as ti:
                for turn_on_strategies, params_list in all_combos_and_params:
                    self.turn_off(self.active, reprepare=False)
                    self.turn_on(turn_on_strategies, reprepare=False)
                    if params_list is not None:
                        for params in params_list:
                            for strat_name in params:
                                self.update_parameters(strategy=strat_name, reprepare=False, **params[strat_name])
                            self.reprepare()
                            at_run += 1
                            ti.progress_bar(start_iter=0, at_iter=at_run, total_length=total_iterations)
                            # Use the final_value() method, because it is much faster 
                            # than a full backtest, once the best combo(s) are found then we will run
                            # full backtests for those combos to get the full details
                            final_value = self.final_value(
                                cash=cash,
                                commission=commission,
                                stop_loss=stop_loss,
                                take_profit=take_profit,
                            )
                            if len(best_fv_combos) < top_n:
                                best_fv_combos.append((final_value, turn_on_strategies, (params, )))
                            else:
                                if final_value > best_fv_combos[-1][0]:
                                    best_fv_combos[-1] = (final_value, turn_on_strategies, (params, ))
                            best_fv_combos = sorted(best_fv_combos, key=lambda x: x[0], reverse=True)
                    
                    else:
                        self.reprepare()
                        at_run += 1
                        ti.progress_bar(start_iter=0, at_iter=at_run, total_length=total_iterations)
                        final_value = self.final_value(
                            cash=cash,
                            commission=commission,
                            stop_loss=stop_loss,
                            take_profit=take_profit,
                        )
                        if len(best_fv_combos) < top_n:
                            best_fv_combos.append((final_value, turn_on_strategies, (self.parameters, )))
                        else:
                            if final_value > best_fv_combos[-1][0]:
                                best_fv_combos[-1] = (final_value, turn_on_strategies, (self.parameters, ))
                        best_fv_combos = sorted(best_fv_combos, key=lambda x: x[0], reverse=True)
        except KeyboardInterrupt:
            self.log_info('Optimization Stopped by User, returning best results so far...')
        
        best_backtest_combos = []
        # Now run the backtest with the best combo
        for _, strategy_names, params in best_fv_combos:
            self.turn_off(self.active, reprepare=False)
            self.turn_on(strategy_names, reprepare=False)
            for strat_name in params[0]:
                self.update_parameters(strategy=strat_name, reprepare=False, **params[0][strat_name])
            self.reprepare()
            best_backtest = self.backtest(
                cash=cash,
                commission=commission,
                stop_loss=stop_loss,
                take_profit=take_profit,
                close_end_position=close_end_position
            )
            best_backtest_combos.append((best_backtest, strategy_names, params))
        if len(best_backtest_combos) == 1:
            return best_backtest_combos[0]
        else:
            return best_backtest_combos

    def parameter_optimize(
        self, 
        cash: float,
        parameter_ranges: dict,
        commission: float = 0,
        stop_loss: Optional[float] = None,
        take_profit: Optional[float] = None,
        top_n: Optional[int] = 10,
        random_iterations: bool = True
    ) -> pd.DataFrame:
        """
        This method will optimize the parameters of a strategy. The parameter_ranges should be a dictionary with the keys as the 
        parameter names and the values as a tuple of the range of values to optimize. The method will return a dictionary with the 
        best parameters and the final value of the strategy with those parameters.
        """
        iterations = 0
        for strat_name in parameter_ranges:
            for param_name in parameter_ranges[strat_name]:
                if iterations == 0:
                    iterations += len(parameter_ranges[strat_name][param_name])
                else:
                    iterations *= len(parameter_ranges[strat_name][param_name])
        
        if iterations > 100_000:
            y_n = input(f'This optimization will run {iterations} iterations, are you sure you want to continue? (y/n): ')
            if y_n.lower() != 'y':
                return pd.DataFrame()


        original_params = ((key, value) for key, value in self.parameters.items())
        parameter_combos = self._get_parameter_combinations(parameter_ranges)
        if random_iterations:
            random.shuffle(parameter_combos)
        len_parameter_combos = len(parameter_combos)
        best_fv_combos = []

        try:
            with TimerInline('Optimizing Parameters Loop', print_starting=False) as ti:
                for i, param_combo in enumerate(parameter_combos):
                    ti.progress_bar(start_iter=0, at_iter=i, total_length=len_parameter_combos)
                    # Update the parameters
                    for strat_name in param_combo:
                        self.update_parameters(strategy=strat_name, reprepare=False, **param_combo[strat_name])
                    self.reprepare()

                    # Use the final_value() method, because it is much faster 
                    # than a full backtest, once the best combo(s) are found then we will run
                    # full backtests for those combos to get the full details
                    final_value = self.final_value(
                        cash=cash,
                        commission=commission,
                        stop_loss=stop_loss,
                        take_profit=take_profit,
                    )
                    len_best = len(best_fv_combos)
                    if len_best < top_n:
                        best_fv_combos.append(dict(
                            final_value=final_value, 
                            buy_signals=self.num_buys,
                            sell_signals=self.num_sells,
                            **self._current_parameters_flat()
                        ))
                    else:
                        for j in range(len_best):
                            if final_value > best_fv_combos[j]['final_value']:
                                best_fv_combos[j] = dict(
                                    final_value=final_value, 
                                    buy_signals=self.num_buys,
                                    sell_signals=self.num_sells,
                                    **self._current_parameters_flat()
                                )
                                break
                    
        except KeyboardInterrupt:
            self.log_info('Optimization Stopped by User, returning best results so far...')
        
        # Get the best combo data into a DataFrame
        data = {}
        for best_combo in best_fv_combos:
            for key, value in best_combo.items():
                if key not in data:
                    data[key] = []
                data[key].append(value)
        df = pd.DataFrame(data)
        df.sort_values(by='final_value', ascending=False, inplace=True)
        df.reset_index(drop=True, inplace=True)

        # Reset the parameters to the original values
        self.update_parameters(**{key: value for key, value in original_params})
        return df 
    
    def turn_off(self, strategies: Union[type[Strategy], str, list, tuple], reprepare: bool = True) -> None:
        """
        This method will turn off a strategy or list of strategies\n
        The strategies can be the class name, the class itself, or a list of class names or classes\n
        Buy and sell signals will be reprepared after turning off the selected strategies\n
        """
        changes_made = False
        if isinstance(strategies, (list, tuple)):
            for s in strategies:
                change_made = self._toggle_strategy(s, turn_off=True)
                if change_made and not changes_made:
                    changes_made = True
        else:
            changes_made = self._toggle_strategy(strategies, turn_off=True)
        if changes_made:
            if reprepare:
                self.prepare()


    def turn_on(self, strategies: Union[type[Strategy], str, list, tuple], reprepare: bool = True) -> None:
        """
        This method will turn on a strategy or list of strategies\n
        The strategies can be the class name, the class itself, or a list of class names or classes\n
        Buy and sell signals will be reprepared after turning on the selected strategies\n
        """        
        changes_made = False
        if isinstance(strategies, (list, tuple)):
            for s in strategies:
                change_made = self._toggle_strategy(s, turn_off=False)
                if change_made and not changes_made:
                    changes_made = True
        else:
            changes_made = self._toggle_strategy(strategies, turn_off=False)
        if changes_made:
            if reprepare:
                self.prepare()
    
    def update_parameters(self, strategy: Optional[Union[str, Strategy, type[Strategy]]] = None, reprepare: bool = True, **parameters):
        """
        This method overrides the super method and will update the parameters of the individual strategies\n
        If you need to update parameters for only a specific strategy, then provide the strategy name\n
        Otherwise, all strategies that share the same parameter will be updated\n
        """
        all_strategies = self.and_strategies + self.or_strategies
        if strategy is not None:
            strt = None
            s_name_lower = None
            if isinstance(strategy, str):
                s_name_lower = strategy.lower()
            elif isinstance(strategy, Strategy):
                s_name_lower = strategy.__class__.__name__.lower()
            elif issubclass(strategy, Strategy):
                s_name_lower = strategy.__name__.lower()
            else:
                raise ValueError(f'Invalid Strategy: {strategy}')       
            
            for s in all_strategies:
                if s.__class__.__name__.lower() == s_name_lower:
                    strt = s
                    break
            else:
                raise ValueError(f'Strategy "{strategy}" not found in any strategies list')
            strt.update_parameters(**parameters)
            self._rename_strategy_indicators_after_prepare(strt)
        else:
            for s in all_strategies:
                s.update_parameters(**parameters)
                self._rename_strategy_indicators_after_prepare(s)
                
        if reprepare:
            self.prepare()

    # Properties ##################################################################################################################################
    @property
    def active(self) -> list:
        """
        A list of the active strategies
        """
        all_strategies = [s.__class__.__name__ for s in self.and_strategies + self.or_strategies]
        return [s for s in all_strategies if s not in self.inactive]

    @property
    def and_names(self) -> list:
        """
        A list of the active "and" strategies
        """
        return [s.__class__.__name__ for s in self.and_strategies]
    
    @property
    def inactive(self) -> list:
        """
        A list of the inactive strategies
        """
        return self.ands_off + self.ors_off
    
    @property
    def or_names(self) -> list:
        """
        A list of the active "or" strategies
        """
        return [s.__class__.__name__ for s in self.or_strategies]
    
    @property
    def all_names(self) -> list:
        """
        A list of all the strategy names
        """
        return self.and_names + self.or_names


#####################################################################################################################################################
#####################################################################################################################################################
# Individual Strategies #############################################################################################################################
class ATR(Strategy):
    """
    Average True Range
    Strategy is Buy when the close price is greater than the previous high plus the ATR times the multiplier\n
    Strategy is Sell when the close price is less than the previous low minus the ATR times the multiplier
    """
    period = Strategy.Parameter(14)
    multiplier = Strategy.Parameter(2.0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            multiplier: float = 2.0,
        ):
        self.period = period
        self.multiplier = multiplier
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.ATR, self.data['high'], self.data['low'], self.data['close'], self.period)

        shift = 1
        # Compute Buy and Sell Signals - pandas is nice because we don't have to declare the "buy" / "sell" columns explicitly
        self.data.loc[self.data['close'] > (self.data['high'].shift(shift) + self.multiplier * self.data['atr'].shift(shift)), self.buy_column] = 1
        self.data.loc[self.data['close'] < (self.data['low'].shift(shift) - self.multiplier * self.data['atr'].shift(shift)), self.sell_column] = 1


class Bollinger(Strategy):
    """
    Bollinger Bands\n
    Strategy is Buy when the close price crosses under the lower Bollinger band\n
    Strategy is Sell when the close price crosses over the upper Bollinger band  
    """
    period= Strategy.Parameter(5)
    stddev_up = Strategy.Parameter(2.0)
    stddev_down = Strategy.Parameter(2.0)
    matype = Strategy.Parameter(talib.MA_Type.SMA)  # value 0

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None,  
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 5,
            stddev_up: float = 2.0,
            stddev_down: float = 2.0,
            matype: int = talib.MA_Type.SMA
        ):
        self.period = period
        self.stddev_up = stddev_up
        self.stddev_down = stddev_down
        self.matype = matype
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        self.I(
            talib.BBANDS,
            self.data['close'],
            self.period,
            self.stddev_up,
            self.stddev_down,
            self.matype,
            i_names=['upper_band', 'middle_band', 'lower_band']
        )
        # Set the buy and sell signals
        self.apply_crossunder(crosser='close', threshold='lower_band', new=self.buy_column)
        self.apply_crossover(crosser='close', threshold='upper_band', new=self.sell_column)


class DEMA(Strategy):
    """
    Double Exponential Moving Average\n
    Strategy is Buy when the short DEMA crosses over the long DEMA\n
    Strategy is Sell when the short DEMA crosses under the long DEMA
    """
    short_period = Strategy.Parameter(20)
    long_period = Strategy.Parameter(50)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None,  
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 20,
            long_period: int = 50
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.DEMA, self.data['close'], self.short_period, i_names='dema_short')
        self.I(talib.DEMA, self.data['close'], self.long_period, i_names='dema_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='dema_short', threshold='dema_long', new=self.buy_column)
        self.apply_crossunder(crosser='dema_short', threshold='dema_long', new=self.sell_column)


class DX(Strategy):
    """
    Directional Movement Index, with the Average Directional Index\n
    Strategy is Buy when the ADX is greater than the threshold and the Plus Directional Movement is greater than the Minus Directional Movement\n
    Strategy is Sell when the ADX is greater than the threshold and the Minus Directional Movement is greater than the Plus Directional Movement
    """
    period = Strategy.Parameter(14)
    adx_threshold = Strategy.Parameter(25)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None,  
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            adx_threshold: int = 25
        ):
        self.period = period
        self.adx_threshold = adx_threshold
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.DX, self.data['high'], self.data['low'], self.data['close'], self.period)
        self.I(talib.PLUS_DM, self.data['high'], self.data['low'], self.period)
        self.I(talib.MINUS_DM, self.data['high'], self.data['low'], self.period)

        # Set the buy and sell signals
        self.data.loc[
            (
                (self.data['dx'] > self.adx_threshold) 
                & (self.data['plus_dm'] > self.data['minus_dm'])
            ), 
            self.buy_column
        ] = 1

        self.data.loc[
            (
                (self.data['dx'] > self.adx_threshold) 
                & (self.data['minus_dm'] > self.data['plus_dm'])
            ), 
            self.sell_column
        ] = 1


class EMA(Strategy):
    """
    Exponential Moving Average\n
    Strategy is Buy when the short EMA is crosses over the long EMA\n
    Strategy is Sell when the short EMA is crosses under the long EMA
    """
    short_period = Strategy.Parameter(12)
    long_period = Strategy.Parameter(26)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None,  
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 12,
            long_period: int = 26
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.EMA, self.data['close'], self.short_period, i_names='ema_short')
        self.I(talib.EMA, self.data['close'], self.long_period, i_names='ema_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='ema_short', threshold='ema_long', new=self.buy_column)
        self.apply_crossunder(crosser='ema_short', threshold='ema_long', new=self.sell_column)


class FibonacciRSI(Strategy):
    """
    Relative Strength Index (RSI) with Fibonacci Levels\n
    Strategy is Buy when current RSI crosses under the oversold and the current price is lower than or equal to the prevoius lower fib level\n
    Strategy is Sell when current RSI is crosses over the overbought and the current price is higher than or equal to the previous upper fib level
    """
    period = Strategy.Parameter(27)
    overbought = Strategy.Parameter(75.0)
    oversold = Strategy.Parameter(55.0)

    """
    DOGE
                            period  overbought  oversold
    0      20428.678343      27          75        55
    1      20300.809284      26          76        57
    2      20300.809284      26          78        57
    3      20300.809284      26          79        57
    4      20300.809284      30          82        56
    
    LTC
    0      22444.256359      22          77        58  # Good for both DOGE and LTC
    1      22444.256359      24          74        58
    2      22444.256359      24          75        58
    3      22444.256359      22          75        57
    4      22444.256359      22          75        58
    
    """

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            overbought: float = 70.0,
            oversold: float = 50.0
        ):
        self.period = period
        self.overbought = overbought
        self.oversold = oversold
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    # Must override abstract method "prepare"
    def prepare(self) -> None:
        # Calculate the RSI Indicator
        self.I(talib.RSI, self.data['close'], self.period)

        # Set the upper and lower fibonacci levels
        self.I(apply_fibonacci_levels, self.data['close'], i_names=['upper_fib', 'lower_fib'])

        self.apply_crossunder(crosser='rsi', threshold=self.oversold, new='rsi_cu')
        self.apply_crossover(crosser='rsi', threshold=self.overbought, new='rsi_co')

        # Set the buy and sell signals
        shift = 1
        self.data.loc[
            (
                (self.data['rsi_cu'] == 1) 
                & (self.data['close'] <= self.data['lower_fib'].shift(shift))
            ),
            self.buy_column
        ] = 1

        self.data.loc[
            (
                (self.data['rsi_co'] == 1) 
                & (self.data['close'] >= self.data['upper_fib'].shift(shift))
            ),
            self.sell_column
        ] = 1


class KAMA(Strategy):
    """
    Kaufman Adaptive Moving Average\n
    Strategy is Buy when the close price crosses over the KAMA\n
    Strategy is Sell when the close price crosses under the KAMA
    """
    short_period = Strategy.Parameter(30)
    long_period = Strategy.Parameter(75)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 30,
            long_period: int = 75
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.KAMA, self.data['close'], self.short_period, i_names='kama_short')
        self.I(talib.KAMA, self.data['close'], self.long_period, i_names='kama_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='kama_short', threshold='kama_long', new=self.buy_column)
        self.apply_crossunder(crosser='kama_short', threshold='kama_long', new=self.sell_column)


class LinearReg(Strategy):
    """
    Linear Regression Line\n
    Strategy is Buy when the close price crosses over the Linear Regression Line\n
    Strategy is Sell when the close price crosses under the Linear Regression Line
    """
    period = Strategy.Parameter(100)
    # period = Strategy.Parameter(2)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 100
            # period: int = 2
        ):
        self.period = period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.LINEARREG, self.data['close'], self.period)
        self.I(talib.SMA, self.data['close'], 25)
        self.I(talib.EMA, self.data['close'], 25)

        # Set the buy and sell signals
        self.apply_crossover(crosser='close', threshold='linearreg', new=self.buy_column)
        self.apply_crossunder(crosser='close', threshold='linearreg', new=self.sell_column)


class MACD(Strategy):
    """
    Moving Average Convergence/Divergence\n
    Strategy is Buy when the MACD crosses over the MACD Signal\n
    Strategy is Sell when the MACD crosses under the MACD Signal
    """
    short_period = Strategy.Parameter(12)
    long_period = Strategy.Parameter(26)
    signal_period = Strategy.Parameter(9)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 12,
            long_period: int = 26,
            signal_period: int = 9
        ):
        self.short_period = short_period
        self.long_period = long_period
        self.signal_period = signal_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(
            talib.MACD,
            self.data['close'],
            self.short_period,
            self.long_period,
            self.signal_period,
            i_names=['macd', 'macd_signal', 'macd_hist']
        )

        # Set the buy and sell signals
        self.apply_crossover(crosser='macd', threshold='macd_signal', new=self.buy_column)
        self.apply_crossunder(crosser='macd', threshold='macd_signal', new=self.sell_column)


class MAMA(Strategy):
    """
    MESA Adaptive Moving Average\n
    Strategy is Buy when the MAMA crosses over the FAMA\n
    Strategy is Sell when the MAMA crosses under the FAMA
    """
    fast_limit = Strategy.Parameter(0.5)  # Cannot be greater than or equal to 1.0
    slow_limit = Strategy.Parameter(0.05)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            fast_limit: float = 0.5,
            slow_limit: float = 0.05
        ):
        self.fast_limit = fast_limit
        self.slow_limit = slow_limit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.MAMA, self.data['close'], self.fast_limit, self.slow_limit, i_names=['mama', 'fama'])

        # Set the buy and sell signals
        self.apply_crossover(crosser='mama', threshold='fama', new=self.buy_column)
        self.apply_crossunder(crosser='mama', threshold='fama', new=self.sell_column)


class Momentum(Strategy):
    """
    Momentum\n
    Strategy is Buy when the Momentum crosses over the buy threshold\n
    Strategy is Sell when the Momentum crosses under the sell threshold    
    """
    period = Strategy.Parameter(14)
    buy_threshold= Strategy.Parameter(1.04)
    sell_threshold = Strategy.Parameter(0.96)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            buy_threshold: int = 1.04,
            sell_threshold: int = 0.96
        ):
        self.period = period
        self.buy_threshold = buy_threshold
        self.sell_threshold = sell_threshold
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.MOM, self.data['close'], self.period)

        # Set the buy and sell signals
        self.apply_crossover(crosser='mom', threshold=self.buy_threshold, new=self.buy_column)
        self.apply_crossunder(crosser='mom', threshold=self.sell_threshold, new=self.sell_column)


class RSI(Strategy):
    """
    Relative Strength Index
    Strategy is Buy when the RSI crosses under the oversold threshold\n
    Strategy is Sell when the RSI crosses over the overbought threshold    
    """
    period = Strategy.Parameter(14)
    overbought = Strategy.Parameter(70.0)
    oversold = Strategy.Parameter(30.0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            overbought: float = 70.0,
            oversold: float = 30.0
        ):
        self.period = period
        self.overbought = overbought
        self.oversold = oversold
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.RSI, self.data['close'], self.period)

        # Set the buy and sell signals
        self.apply_crossunder(crosser='rsi', threshold=self.oversold, new=self.buy_column)
        self.apply_crossover(crosser='rsi', threshold=self.overbought, new=self.sell_column)


class SMA(Strategy):
    """
    Simple Moving Average\n
    Strategy is Buy when the short SMA crosses over the long SMA\n
    Strategy is Sell when the short SMA crosses under the long SMA    
    """
    short_period = Strategy.Parameter(25)
    long_period = Strategy.Parameter(100)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 25,
            long_period: int = 100,
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.SMA, self.data['close'], self.short_period, i_names='sma_short')
        self.I(talib.SMA, self.data['close'], self.long_period, i_names='sma_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='sma_short', threshold='sma_long', new=self.buy_column)
        self.apply_crossunder(crosser='sma_short', threshold='sma_long', new=self.sell_column)


class StochasticRSI(Strategy):
    """
    Stochastic Relative Strength Index    
    Strategy is Buy when the K and D values have both crossed under the oversold threshold\n
    Strategy is Sell when the K and D values have both crossed over the overbought threshold
    """
    period = Strategy.Parameter(14)
    k_period = Strategy.Parameter(5)
    d_period = Strategy.Parameter(3)
    d_matype = Strategy.Parameter(0.0)
    overbought = Strategy.Parameter(0.8)
    oversold = Strategy.Parameter(0.2)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            k_period: int = 5,
            d_period: int = 3,
            d_matype: float = 0.0,
            overbought: float = 0.8,
            oversold: float = 0.2
        ):
        self.period = period
        self.k_period = k_period
        self.d_period = d_period
        self.d_matype = d_matype
        self.overbought = overbought
        self.oversold = oversold
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(
            talib.STOCHRSI,
            self.data['close'],
            self.period,
            self.k_period,
            self.d_period,
            self.d_matype,
            i_names=['k', 'd']
        )

        self.apply_crossunder(crosser='k', threshold=self.oversold, new='k_cu')
        self.apply_crossunder(crosser='d', threshold=self.oversold, new='d_cu')
        self.apply_crossover(crosser='k', threshold=self.overbought, new='k_co')
        self.apply_crossover(crosser='d', threshold=self.overbought, new='d_co')

        # Set the buy and sell signals
        self.data.loc[
            (
                (self.data['k_cu'] == 1)
                & (self.data['d_cu'] == 1)
            ), 
            self.buy_column
        ] = 1

        self.data.loc[
            (
                (self.data['k_co'] == 1)
                & (self.data['d_co'] == 1)
            ), 
            self.sell_column
        ] = 1


class STDPeriods(Strategy):
    """
    Standard Deviation calculated by splitting the data into periods "n_periods"
    Strategy is Buy when the close price crosses under the lower STD\n
    Strategy is Sell when the close price crosses over the upper STD
    """
    period_len = Strategy.Parameter(208)
    std_multiplier = Strategy.Parameter(1.0)
    trending_on = Strategy.Parameter(1)  # Or 0 (True/False, but Parmaters must be numeric)
    trend_divisor = Strategy.Parameter(2.0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period_len: int = 208,
            std_multiplier: float = 1.0,
            trending_on: int = 1,
            trend_divisor: float = 2.0
        ):
        self.period_len = period_len
        self.std_multiplier = std_multiplier
        self.trending_on = trending_on
        self.trend_divisor = trend_divisor
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(
            stddevs_by_period_length, 
            self.data['close'], 
            self.period_len, 
            self.std_multiplier, 
            self.trending_on, 
            self.trend_divisor,
            i_names=['upper_std', 'lower_std']
        )

        # Set the buy and sell signals
        self.apply_crossunder(crosser='close', threshold='lower_std', new=self.buy_column)
        self.apply_crossover(crosser='close', threshold='upper_std', new=self.sell_column)


class TEMA(Strategy):
    """
    Triple Expontential Moving Average
    Strategy is Buy when the tema_short crosses over the tema_long\n
    Strategy is Sell when the tema_short crosses under the tema_long
    """
    short_period = Strategy.Parameter(30)
    long_period = Strategy.Parameter(75)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 30,
            long_period: int = 75
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.TEMA, self.data['close'], self.short_period, i_names='tema_short')
        self.I(talib.TEMA, self.data['close'], self.long_period, i_names='tema_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='tema_short', threshold='tema_long', new=self.buy_column)
        self.apply_crossunder(crosser='tema_short', threshold='tema_long', new=self.sell_column)


class TRIMA(Strategy):
    """
    Triangular Moving Average
    Strategy is Buy when the trima_short crosses over the trima_long\n
    Strategy is Sell when the trima_short crosses under the trima_long
    """
    short_period = Strategy.Parameter(30)
    long_period = Strategy.Parameter(75)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 30,
            long_period: int = 75
        ):
        self.short_period = short_period
        self.long_period = long_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.TRIMA, self.data['close'], self.short_period, i_names='trima_short')
        self.I(talib.TRIMA, self.data['close'], self.long_period, i_names='trima_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='trima_short', threshold='trima_long', new=self.buy_column)
        self.apply_crossunder(crosser='trima_short', threshold='trima_long', new=self.sell_column)


class TripleConfluence(Strategy):
    """
    Triangular Moving Average
    Strategy is Buy when the trima_short crosses over the trima_long\n
    Strategy is Sell when the trima_short crosses under the trima_long
    """
    ema_short_period = Strategy.Parameter(20)
    ema_middle_period = Strategy.Parameter(50)
    ema_long_period = Strategy.Parameter(100)

    rsi_period = Strategy.Parameter(14)
    rsi_overbought = Strategy.Parameter(60.0)
    rsi_oversold = Strategy.Parameter(40.0)

    macd_short_period = Strategy.Parameter(12)
    macd_long_period = Strategy.Parameter(26)
    macd_signal_period = Strategy.Parameter(9)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            ema_short_period: int = 20,
            ema_middle_period: int = 50,
            ema_long_period: int = 100,
            rsi_period: int = 14,
            rsi_overbought: float = 60.0,
            rsi_oversold: float = 40.0,
            macd_short_period: int = 12,
            macd_long_period: int = 26,
            macd_signal_period: int = 9
        ):
        self.ema_short_period = ema_short_period
        self.ema_middle_period = ema_middle_period
        self.ema_long_period = ema_long_period
        self.rsi_period = rsi_period
        self.rsi_overbought = rsi_overbought
        self.rsi_oversold = rsi_oversold
        self.macd_short_period = macd_short_period
        self.macd_long_period = macd_long_period
        self.macd_signal_period = macd_signal_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.EMA, self.data['close'], self.ema_short_period, i_names='ema_short')
        self.I(talib.EMA, self.data['close'], self.ema_middle_period, i_names='ema_middle')
        self.I(talib.EMA, self.data['close'], self.ema_long_period, i_names='ema_long')

        self.I(talib.RSI, self.data['close'], self.rsi_period)

        self.I(
            talib.MACD,
            self.data['close'],
            self.macd_short_period,
            self.macd_long_period,
            self.macd_signal_period,
            i_names=['macd', 'macd_signal', 'macd_hist']
        )

        self.data.loc[
            (
                (
                    (self.data['ema_short'] > self.data['ema_middle'])
                    & (self.data['ema_middle'] > self.data['ema_long'])
                )
                & (
                    (self.data['macd'] > self.data['macd_signal'])
                    & (self.data['macd_signal'] > 0)
                )
                & (
                    (self.rsi_oversold < self.data['rsi'])
                    & (self.data['rsi'] < self.rsi_overbought)
                )
                & (self.data['close'] > self.data['ema_short'])
            ),
            self.sell_column
        ] = 1

        self.data.loc[
            (
                (
                    (self.data['ema_short'] < self.data['ema_middle'])
                    & (self.data['ema_middle'] < self.data['ema_long'])
                )
                & (
                    (self.data['macd'] < self.data['macd_signal'])
                    & (self.data['macd_signal'] < 0)
                )
                & (
                    (self.rsi_oversold < self.data['rsi'])
                    & (self.data['rsi'] < self.rsi_overbought)
                )
                & (self.data['close'] < self.data['ema_short'])
            ),
            self.buy_column
        ] = 1








#####################################################################################################################################################
#####################################################################################################################################################
# Custom Strategies ################################################################################################################################
class AllStrategiesOr(Combo):
    def __init__(
        self,
        # Strategy Params
        data: pd.DataFrame, 
        use_data_inplace: bool = False, 
        column_mappers: Optional[dict] = None,
    ):
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            and_list=None,
            or_list=[
                ATR,
                Bollinger,
                DEMA,
                DX,
                EMA,
                FibonacciRSI,
                KAMA,
                MACD,
                MAMA,
                Momentum,
                RSI,
                SMA,
                StochasticRSI,
                TRIMA
            ],
            and_strict=False
        )



class DogeLTCSlayer(Combo):
    def __init__(
        self,
        # Strategy Params
        data: pd.DataFrame, 
        use_data_inplace: bool = False, 
        column_mappers: Optional[dict] = None,
    ):
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            and_list=[KAMA],
            or_list=[ATR, DEMA, EMA, FibonacciRSI, TRIMA],
            and_strict=True
        )


class FibSmaMod(Combo):
    def __init__(
        self,
        # Strategy Params
        data: pd.DataFrame, 
        use_data_inplace: bool = False, 
        column_mappers: Optional[dict] = None,
    ):
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            or_list=[
                {FibonacciRSI: {
                    'period': 22,
                    'overbought': 72,
                    'oversold': 50
                }},
                {SMA: {
                    'short_period': 18,
                    'long_period': 160
                }},
            ],
        )


class Spikes(Strategy):
    upper_look_behind = Strategy.Parameter(2)
    lower_look_behind = Strategy.Parameter(3)
    upper_spike = Strategy.Parameter(2.6)
    lower_spike = Strategy.Parameter(2.5)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            upper_look_behind: int = 2,
            lower_look_behind: int = 3,
            upper_spike: int = 2.6,
            lower_spike: int = 2.5
        ):
        self.upper_look_behind = upper_look_behind
        self.lower_look_behind = lower_look_behind
        self.lower_spike = lower_spike
        self.upper_spike = upper_spike
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(lambda series: series.pct_change(periods=int(self.upper_look_behind)) * 100, self.data['close'], i_names='upper_pct_change')
        self.I(lambda series: series.pct_change(periods=int(self.lower_look_behind)) * 100, self.data['close'], i_names='lower_pct_change')

        self.data.loc[self.data['lower_pct_change'] < -self.lower_spike, self.buy_column] = 1
        self.data.loc[self.data['upper_pct_change'] > self.upper_spike, self.sell_column] = 1



class Waves(Strategy):
    """
    DOGE 5m ($5,000, 2.5 months)
        final_value  buy_signals  sell_signals  gain_pct  retract_pct  reset_low_pct  reset_high_pct
0   9942.594580           16            15         7            8             24              15
1   9744.978874           13            12         8           10             18              15
2   9688.531991           12            11         8           10             15              16
3   9675.643744           12            11         8           10             15              17
4   9609.902641           12            11         8           10             15              18
5   9589.852626           14            13         8            7             22              15
6   9587.027469           21            20         5            5             21              18
7   9560.889207           21            20         5            5             21              19
8   9549.726371           14            13         7            9             18              15
9   9548.782361           21            20         5            5             22              18
    """


    gain_pct = Strategy.Parameter(8)
    retract_pct = Strategy.Parameter(10)
    reset_low_pct = Strategy.Parameter(15)
    reset_high_pct = Strategy.Parameter(16)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            gain_pct: int = 7.5,
            retract_pct: int = 7.5,
            reset_low_pct: int = 20.0,
            reset_high_pct: int = 20.0
        ):
        self.gain_pct = gain_pct
        self.retract_pct = retract_pct
        self.reset_low_pct = reset_low_pct
        self.reset_high_pct = reset_high_pct
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.data[self.buy_column] = np.nan
        self.data[self.sell_column] = np.nan
        self.data['buy_type'] = None
        self.data['sell_type'] = None
        buy_anchor = None
        sell_anchor = None
        in_position = False
        buy_anchor_reset = False
        sell_anchor_reset = False
        for row in self.data.itertuples():
            # Do the inital buy at whatever price
            if sell_anchor is None:
                self.data.at[row.Index, self.buy_column] = 1
                self.data.at[row.Index, 'buy_type'] = 'initial'
                sell_anchor = row.close
                in_position = True
            
            # Examine if we should sell
            elif in_position and row.close >= sell_anchor * (1 + (self.gain_pct / 100)):
                self.data.at[row.Index, self.sell_column] = 1
                if sell_anchor_reset:
                    self.data.at[row.Index, 'sell_type'] = 'reset'
                    sell_anchor_reset = False
                else:
                    self.data.at[row.Index, 'sell_type'] = 'normal'
                buy_anchor = row.close
                in_position = False

            # Examine if we should buy
            elif not in_position and buy_anchor is not None and row.close <= buy_anchor * (1 - (self.retract_pct / 100)):
                self.data.at[row.Index, self.buy_column] = 1
                if buy_anchor_reset:
                    self.data.at[row.Index, 'buy_type'] = 'reset'
                    buy_anchor_reset = False
                else:
                    self.data.at[row.Index, 'buy_type'] = 'normal'
                sell_anchor = row.close
                in_position = True
            
            # Examine if we should reset the sell anchor
            elif in_position and row.close <= sell_anchor * (1 - (self.reset_low_pct / 100)):
                sell_anchor = row.close
                sell_anchor_reset = True

            # Examine if we should reset the buy anchor
            elif not in_position and row.close >= buy_anchor * (1 + (self.reset_high_pct / 100)):
                buy_anchor = row.close
                buy_anchor_reset = True



class JakeStrat(Strategy):
    """
    Jake Strat
    Buy:
        - Get the close of previous midnight
        - Get the lowest close
        - Only buy within the timeframe of current midnight up to 4am
        - 
    Strategy is Sell when the close price crosses under the TRIMA
    """
    period: int = 14

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14
        ):
        self.period = period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )




class PSLMacd(Strategy):
    """
    Moving Average Convergence/Divergence\n
    Strategy is Buy when the MACD crosses over the MACD Signal\n
    Strategy is sell when it is gaurenteed profit including commission OR when the stop loss percentage is hit
    """
    short_period = Strategy.Parameter(12)
    long_period = Strategy.Parameter(26)
    signal_period = Strategy.Parameter(9)
    commission = Strategy.Parameter(0.46)
    stop_loss = Strategy.Parameter(3)
    min_profit = Strategy.Parameter(0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 12,
            long_period: int = 26,
            signal_period: int = 9,
            commission: float = 0.46,
            stop_loss: float = 3,
            min_profit: float = 0
        ):
        self.short_period = short_period
        self.long_period = long_period
        self.signal_period = signal_period
        self.commission = commission
        self.stop_loss = stop_loss
        self.min_profit = min_profit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(
            talib.MACD,
            self.data['close'],
            self.short_period,
            self.long_period,
            self.signal_period,
            i_names=['macd', 'macd_signal', 'macd_hist']
        )
        # Set the buy and sell signals
        self.apply_crossover(crosser='macd', threshold='macd_signal', new=self.buy_column)
        self.apply_profit_or_stop_loss(
            commission=self.commission,
            stop_loss=self.stop_loss,
            min_profit=self.min_profit
        )
        


class PSLSma(Strategy):
    """
    Simple Moving Average\n
    Strategy is Buy when the short SMA crosses over the long SMA\n
    Strategy is sell when it is gaurenteed profit including commission OR when the stop loss percentage is hit 
    """
    short_period = Strategy.Parameter(25)
    long_period = Strategy.Parameter(100)
    commission = Strategy.Parameter(0.46)
    stop_loss = Strategy.Parameter(3)
    min_profit = Strategy.Parameter(0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            short_period: int = 25,
            long_period: int = 100,
            commission: float = 0.46,
            stop_loss: float = 3,
            min_profit: float = 0
        ):
        self.short_period = short_period
        self.long_period = long_period
        self.commission = commission
        self.stop_loss = stop_loss
        self.min_profit = min_profit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.SMA, self.data['close'], self.short_period, i_names='sma_short')
        self.I(talib.SMA, self.data['close'], self.long_period, i_names='sma_long')

        # Set the buy and sell signals
        self.apply_crossover(crosser='sma_short', threshold='sma_long', new=self.buy_column)
        self.apply_profit_or_stop_loss(
            commission=self.commission,
            stop_loss=self.stop_loss,
            min_profit=self.min_profit
        )
        


class PSLKama(Strategy):
    """
    Kaufman Adaptive Moving Averagen\n
    Strategy is Buy when the close price crosses over the KAMA\n
    Strategy is sell when it is gaurenteed profit including commission OR when the stop loss percentage is hit 
    """
    period = Strategy.Parameter(14)
    commission = Strategy.Parameter(0.46)
    stop_loss = Strategy.Parameter(3)
    min_profit = Strategy.Parameter(0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14,
            commission: float = 0.46,
            stop_loss: float = 3,
            min_profit: float = 0
        ):
        self.period = period
        self.commission = commission
        self.stop_loss = stop_loss
        self.min_profit = min_profit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.KAMA, self.data['close'], self.period)

        # Set the buy and sell signals
        self.apply_crossover(crosser='close', threshold='kama', new=self.buy_column)
        self.apply_profit_or_stop_loss(
            commission=self.commission,
            stop_loss=self.stop_loss,
            min_profit=self.min_profit
        )
        


class PSLFibSmaMod(Strategy):
    """
    Combined Fibonacci RSI with SMA, using other params then the defaults for the base classes
    Strategy is Buy when the short SMA crosses over the long SMA\n
    AND Buy when current RSI crosses under the oversold and the current price is lower than or equal to the prevoius lower fib level\n
    Strategy is sell when it is gaurenteed profit including commission OR when the stop loss percentage is hit 
    """
    # FibonacciRSI Params
    period = Strategy.Parameter(22)
    overbought = Strategy.Parameter(72)
    oversold = Strategy.Parameter(50)

    # SMA Params    
    short_period = Strategy.Parameter(18)
    long_period = Strategy.Parameter(160)

    # Profit/Stop Loss Params
    commission = Strategy.Parameter(0.46)
    stop_loss = Strategy.Parameter(3)
    min_profit = Strategy.Parameter(0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 22,
            overbought: float = 72,
            oversold: float = 50,
            
            short_period: int = 18,
            long_period: int = 160,

            commission: float = 0.46,
            stop_loss: float = 3,
            min_profit: float = 0
        ):
        self.period = period
        self.overbought = overbought
        self.oversold = oversold

        self.short_period = short_period
        self.long_period = long_period

        self.commission = commission
        self.stop_loss = stop_loss
        self.min_profit = min_profit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Calculate the RSI Indicator
        self.I(talib.RSI, self.data['close'], self.period)

        # Set the upper and lower fibonacci levels
        self.I(apply_fibonacci_levels, self.data['close'], i_names=['upper_fib', 'lower_fib'])

        # Prepare SMA Indicators by Params
        self.I(talib.SMA, self.data['close'], self.short_period, i_names='sma_short')
        self.I(talib.SMA, self.data['close'], self.long_period, i_names='sma_long')

        # Apply the RSI crosses
        self.apply_crossunder(crosser='rsi', threshold=self.oversold, new='rsi_cu')
        self.apply_crossover(crosser='rsi', threshold=self.overbought, new='rsi_co')

        # Set the buy and sell signals
        # Set SMA Buy Signals
        self.apply_crossover(crosser='sma_short', threshold='sma_long', new=self.buy_column)

        # Set the Fib Buy Signals
        shift = 1
        self.data.loc[
            (
                (self.data['rsi_cu'] == 1) 
                & (self.data['close'] <= self.data['lower_fib'].shift(shift))
            ),
            self.buy_column
        ] = 1
        # Set the sell signals
        self.apply_profit_or_stop_loss(
            commission=self.commission,
            stop_loss=self.stop_loss,
            min_profit=self.min_profit
        )
        


class PSLDogeLTCSlayer(Strategy):
    """
    Combined Fibonacci RSI with SMA, using other params then the defaults for the base classes
    Strategy is Buy when the short SMA crosses over the long SMA\n
    AND Buy when current RSI crosses under the oversold and the current price is lower than or equal to the prevoius lower fib level\n
    Strategy is sell when it is gaurenteed profit including commission OR when the stop loss percentage is hit 
    """
    # KAMA Params
    kama_period = Strategy.Parameter(14)

    # FibonacciRSI Params
    fib_period = Strategy.Parameter(22)
    fib_overbought = Strategy.Parameter(72)
    fib_oversold = Strategy.Parameter(50)

    # DEMA Params    
    dema_short_period = Strategy.Parameter(20)
    dema_long_period = Strategy.Parameter(50)

    # EMA Params
    ema_short_period = Strategy.Parameter(12)
    ema_long_period = Strategy.Parameter(26)

    # TRIMA Params
    trima_period = Strategy.Parameter(14)

    # Profit/Stop Loss Params
    commission = Strategy.Parameter(0.46)
    stop_loss = Strategy.Parameter(3)
    min_profit = Strategy.Parameter(0)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            kama_period: int = 14,
            
            fib_period: int = 22,
            fib_overbought: float = 72,
            fib_oversold: float = 50,
            
            dema_short_period: int = 20,
            dema_long_period: int = 50,
            
            ema_short_period: int = 12,
            ema_long_period: int = 26,

            trima_period: int = 14,

            commission: float = 0.46,
            stop_loss: float = 3,
            min_profit: float = 0
        ):
        self.kama_period = kama_period

        self.fib_period = fib_period
        self.fib_overbought = fib_overbought
        self.fib_oversold = fib_oversold

        self.dema_short_period = dema_short_period
        self.dema_long_period = dema_long_period

        self.ema_short_period = ema_short_period
        self.ema_long_period = ema_long_period

        self.trima_period = trima_period

        self.commission = commission
        self.stop_loss = stop_loss
        self.min_profit = min_profit
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the KAMA Indicator (this is the anchor)
        self.I(talib.KAMA, self.data['close'], self.kama_period)

        # Prepare the DEMA Indicators
        self.I(talib.DEMA, self.data['close'], self.dema_short_period, i_names='dema_short')
        self.I(talib.DEMA, self.data['close'], self.dema_long_period, i_names='dema_long')

        # Prepare EMA Indicators by Params
        self.I(talib.EMA, self.data['close'], self.ema_short_period, i_names='ema_short')
        self.I(talib.EMA, self.data['close'], self.ema_long_period, i_names='ema_long')

        # Prepare the FibonacciRSI Indicators and crosses
        self.I(talib.RSI, self.data['close'], self.fib_period)
        self.I(apply_fibonacci_levels, self.data['close'], i_names=['upper_fib', 'lower_fib'])
        self.apply_crossunder(crosser='rsi', threshold=self.fib_oversold, new='rsi_cu')
        self.apply_crossover(crosser='rsi', threshold=self.fib_overbought, new='rsi_co')

        # Prepare the TRIMA Indicator
        self.I(talib.TRIMA, self.data['close'], self.trima_period)        

        # Set the buy and sell signals
        # The KAMA Crossover will be the anchor buy signal, the true buy signal will be
        # KAMA and at least one of the other strategies
        self.apply_crossover(crosser='close', threshold='kama', new='kama_buy')
        self.apply_crossover(crosser='dema_short', threshold='dema_long', new='dema_buy')
        self.apply_crossover(crosser='ema_short', threshold='ema_long', new='ema_buy')
        self.apply_crossover(crosser='close', threshold='trima', new='trima_buy')
        self.data['fib_buy'] = np.nan
        shift = 1
        self.data.loc[
            (
                (self.data['rsi_cu'] == 1) 
                & (self.data['close'] <= self.data['lower_fib'].shift(shift))
            ),
            'fib_buy'
        ] = 1

        # Get the final buy signals
        self.data.loc[
            (
                (self.data['kama_buy'].notna())
                & (
                    (self.data['dema_buy'].notna())
                    | (self.data['ema_buy'].notna())
                    | (self.data['fib_buy'].notna())
                    | (self.data['trima_buy'].notna())
                )
            ),
            self.buy_column
        ] = 1

        # Set the sell signals
        self.apply_profit_or_stop_loss(
            commission=self.commission,
            stop_loss=self.stop_loss,
            min_profit=self.min_profit
        )
        

#####################################################################################################################################################
# Different Crossing Combos #########################################################################################################################
"""
*over meaning crossover buy signal*
*"maybe" means the final value was a little under the starting value*
*"yes" means the final value was over the starting value*

KAMA over TRIMA (maybe) [kama_period = 105, trima_period = 148]
KAMA over EMA (maybe) [kama_period = 85, ema_period = 135]

DEMA over SMA (maybe) [dema_period = 124, sma_period = 146]
DEMA over EMA (maybe) [dema_period = 103, ema_period = 148]

EMA over DEMA (maybe) [ema_period = 58, dema_period = 120]
"""



class EmaDemaCross(Strategy): ################
    """
    Testing Strategy for KAMA and DEMA crossover
    Strategy is Buy when the DEMA crosses over the KAMA\n
    Strategy is Sell when the DEMA crosses under the KAMA
    """
    """
    ON DOGE (maybe) for current class params
    25,229 / 25,000 ETH 12/28/2024 - 01/05/2025 @ ema_period = 63, dema_period = 141
    """
    ema_period = Strategy.Parameter(58)
    dema_period = Strategy.Parameter(120)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            ema_period: int = 58,         
            dema_period: int = 120,
        ):
        self.ema_period = ema_period
        self.dema_period = dema_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the Indicators
        self.I(talib.EMA, self.data['close'], self.ema_period)
        self.I(talib.DEMA, self.data['close'], self.dema_period)

        self.apply_crossover(crosser='ema', threshold='dema', new=self.buy_column)
        self.apply_crossunder(crosser='ema', threshold='dema', new=self.sell_column)



class DemaEmaCross(Strategy): ################
    """
    Testing Strategy for KAMA and DEMA crossover
    Strategy is Buy when the DEMA crosses over the KAMA\n
    Strategy is Sell when the DEMA crosses under the KAMA
    """
    """
    ON DOGE (maybe) for current class params
    25,070 / 25,000 ETH 12/28/2024 - 01/05/2025 @ dema_period = 107, ema_period = 62
    """
    dema_period = Strategy.Parameter(103)
    ema_period = Strategy.Parameter(148)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            dema_period: int = 103,         
            ema_period: int = 148,
        ):
        self.dema_period = dema_period
        self.ema_period = ema_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the Indicators
        self.I(talib.DEMA, self.data['close'], self.dema_period)
        self.I(talib.EMA, self.data['close'], self.ema_period)

        self.apply_crossover(crosser='dema', threshold='ema', new=self.buy_column)
        self.apply_crossunder(crosser='dema', threshold='ema', new=self.sell_column)



class DemaSmaCross(Strategy):
    """
    Testing Strategy for KAMA and DEMA crossover
    Strategy is Buy when the DEMA crosses over the KAMA\n
    Strategy is Sell when the DEMA crosses under the KAMA
    """
    """
    ONLY ON DOGE (maybe) for current class params
    """
    dema_period = Strategy.Parameter(124)
    sma_period = Strategy.Parameter(146)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            dema_period: int = 124,         
            sma_period: int = 146,
        ):
        self.dema_period = dema_period
        self.sma_period = sma_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the Indicators
        self.I(talib.DEMA, self.data['close'], self.dema_period)
        self.I(talib.SMA, self.data['close'], self.sma_period)

        self.apply_crossover(crosser='dema', threshold='sma', new=self.buy_column)
        self.apply_crossunder(crosser='dema', threshold='sma', new=self.sell_column)



class KamaEmaCross(Strategy):
    """
    Testing Strategy for KAMA and DEMA crossover
    Strategy is Buy when the DEMA crosses over the KAMA\n
    Strategy is Sell when the DEMA crosses under the KAMA
    """
    """
    ON DOGE (maybe) for current class params
    25,028 / 25,000 ETH 12/28/2024 - 01/05/2025 @ kama_period = 69, ema_period = 150(max: maybe try with greater than)
    """
    kama_period = Strategy.Parameter(85)
    ema_period = Strategy.Parameter(135)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            kama_period: int = 85,         
            ema_period: int = 135,
        ):
        self.kama_period = kama_period
        self.ema_period = ema_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the Indicators
        self.I(talib.KAMA, self.data['close'], self.kama_period)
        self.I(talib.EMA, self.data['close'], self.ema_period)

        self.apply_crossover(crosser='kama', threshold='ema', new=self.buy_column)
        self.apply_crossunder(crosser='kama', threshold='ema', new=self.sell_column)



class KamaTrimaCross(Strategy):
    """
    Testing Strategy for KAMA and DEMA crossover
    Strategy is Buy when the DEMA crosses over the KAMA\n
    Strategy is Sell when the DEMA crosses under the KAMA
    """
    """
    ONLY ON DOGE (maybe) for current class params
    """
    kama_period = Strategy.Parameter(105)
    trima_period = Strategy.Parameter(148)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            kama_period: int = 105,         
            trima_period: int = 148,
        ):
        self.kama_period = kama_period
        self.trima_period = trima_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Set the Indicators
        self.I(talib.KAMA, self.data['close'], self.kama_period)
        self.I(talib.TRIMA, self.data['close'], self.trima_period)

        self.apply_crossover(crosser='kama', threshold='trima', new=self.buy_column)
        self.apply_crossunder(crosser='kama', threshold='trima', new=self.sell_column)


        
#####################################################################################################################################################
class LinRegEmaSmaCross(Strategy):
    """
    Buy SMA Crossunder LIN
    SELL EMA Crossover LIN
    """
    """
    """
    lin_period = Strategy.Parameter(88) # (100)
    sma_period = Strategy.Parameter(26) # (25)
    ema_period = Strategy.Parameter(46) # (25)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            lin_period: int = 88, #100,
            sma_period: int = 26, #25,
            ema_period: int = 46, #25,
        ):
        self.lin_period = lin_period
        self.sma_period = sma_period
        self.ema_period = ema_period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.LINEARREG, self.data['close'], self.lin_period)
        self.I(talib.SMA, self.data['close'], self.sma_period)
        self.I(talib.EMA, self.data['close'], self.ema_period)

        # Set the buy and sell signals
        self.apply_crossunder(crosser='sma', threshold='linearreg', new=self.buy_column)
        self.apply_crossover(crosser='ema', threshold='linearreg', new=self.sell_column)



class StdTRIMA(Strategy):
    """
    Triangular Moving Average as compared to the standard deviation
    Strategy is Buy when the close price crosses over the TRIMA\n
    Strategy is Sell when the close price crosses under the TRIMA
    """
    period = Strategy.Parameter(14)

    def __init__(
            self, 
            # Strategy Params
            data: pd.DataFrame, 
            use_data_inplace: bool = False, 
            column_mappers: Optional[dict] = None, 
            clean_columns: bool = True,
            init_prepare: bool = True,

            # Custom Params
            period: int = 14
        ):
        self.period = period
        super().__init__(
            data=data, 
            use_data_inplace=use_data_inplace, 
            column_mappers=column_mappers,
            clean_columns=clean_columns,
            init_prepare=init_prepare
        )

    def prepare(self):
        # Prepare Indicators by Params
        self.I(talib.TRIMA, self.data['close'], self.period)
        self.I(talib.STDDEV, self.data['close'])

        # Set the buy and sell signals
        self.apply_crossover(crosser='close', threshold='trima', new=self.buy_column)
        self.apply_crossunder(crosser='close', threshold='trima', new=self.sell_column)






        

        